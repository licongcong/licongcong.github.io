---
layout:     post
title:      "选择排序"
date:       2018-10-14
author:     "CongcongLi"
mathjax:    true
tags:
    - 数据结构
    - 算法
    - 选择排序
---

## 目录

1. [算法思想](#1)

2. [具体过程](#2)

3. [算法实现](#3)

4. [算法分析](#4)


## <span id="1">1. 算法思想</span>

1. 首先在未排序序列中找到最小元素，存放到排序序列的起始位置。
2. 然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。
3. 重复2，直到所有元素均排序完毕。

## <span id="2">2. 对以下数组进行选择排序：</span>

| index |  0   |  1   |  2   |  3   |  4   |  5   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
| data  |  4   |  6   |  3   |  1   |  7   |  2   |

1. 首先从下标范围`[0, 5]`中找到最小的元素`1` ，下标为`3`，将其与下标为`0`的元素进行交换：

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  |  6   |  3   |  4   |  7   |  2   |

2. 接下来从下标范围`[1, 5]`中找到最小的元素`2`，下标为`5`，将其与下标为`1`的元素进行交换：

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  |  3   |  4   |  7   |  6   |

3. 接下来从下标范围`[2, 5]`中找到最小的元素`3`，下标为`2`，元素`3`已在合适的位置上，不需要交换：

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  | `3`  |  4   |  7   |  6   |

4. 接下来从下标范围`[3, 5]`中找到最小的元素`4`，下标为`3`，元素`4`已在合适的位置上，不需要交换：

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  | `3`  | `4`  |  7   |  6   |

5. 接下来从下标范围`[4, 5]`中找到最小的元素`6`，下标为`5`，将其与下标为`4`的元素进行交换：

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  | `3`  | `4`  | `6`  |  7   |

6. 剩余最后一个元素，不再需要交换，排序完成。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  | `3`  | `4`  | `6`  | `7`  |

## <span id="3">3. 算法实现</span>

```c++
template <typename T>
void selectionSort(T arr[], int size) {
    int minIndex;
    for (int i=0; i < size-1; i++) {	// 需要　size - 1 次循环
        minIndex = i;

        for (int j=i+1; j < size; j++) {	// 在[i, size-1]中，找出最小元素的下标
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        if (minIndex != i) {		// 将找到的第 i 小的元素与位置 i 上的元素调换位置
            swap(arr[minIndex], arr[i]);
        }
    }
    return;
}
```

## <span id="4">4. 算法分析</span>

1. 时间复杂度为 $O(N^2) $
   1. 总共需要比较的次数为$N = (n-1) + (n-2) + (n-3) + \dots + 1 = n \times (n-1) / 2$
   2. 最好的情况是已经有序，需要交换 $0$ 次。
   3. 最坏的情况是为$ [0, n-2] $为有序，$ arr[n-1] $最小，此时需要交换 $ n-1 $ 次。
2. 空间复杂度 $O(1) $
   * 需要一个 `minIndex`记录最小元素的位置，故而空间复杂度为 $O(1)$ 。