---
layout:     post
title:      "插入排序"
date:       2018-10-14
author:     "CongcongLi"
mathjax:    true
tags:
    - 数据结构
    - 算法
    - 插入排序
---

## 目录

1. [算法思想](#1)

2. [具体过程](#2)

3. [算法实现](#3)

4. [算法分析](#4)


## <span id="1">1. 算法思想</span>

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

## <span id="2">2. 对以下数组进行插入排序：</span>

| index |  0   |  1   |  2   |  3   |  4   |  5   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
| data  |  4   |  6   |  3   |  1   |  7   |  2   |

1. 首先取出下标为`1`的元素 $6$ ，将其与`[0, 0]`的元素从后向前进行比较：

   1. $ 6 > 4 $，比较结束，$6$ 应该放置的位置为`1`。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `4`  | `6`  |  3   |  1   |  7   |  2   |

2. 接下来取出下标为`2`的元素 $3$ ，将其与`[0, 1]`的元素从后向前进行比较：

   1. 首先将 $3$ 与 $6$ 进行比较，$ 6 > 3 $，$6$ 后移一位　
   2. 然后将 $3$ 与 $4$ 进行比较，$4 > 3 $，$4$ 后移一位。
   3. 比较结束，将 $3$ 放到下标为`0`的位置上。 

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `3`  | `4`  | `6`  |  1   |  7   |  2   |

3. 接下来取出下标为`3`的元素 $1$ ，将其与`[0, 2]`的元素从后向前进行比较：

   1. 首先将 $1$ 与 $6$ 进行比较，$ 6 > 1 $，$6$ 后移一位。
   2. 然后将 $1$ 与 $4$ 进行比较，$4 > 1 $，$4$ 后移一位。
   3. 然后将 $1$ 与 $3$ 进行比较，$3 > 1 $，$3$ 后移一位。
   4. 比较结束，将 $1$ 放到下标为`0`的位置上。 

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `3`  | `4`  | `6`  |  7   |  2   |

4. 接下来取出下标为`4`的元素 $7$ ，将其与`[0, 3]`的元素从后向前进行比较：

   1. $ 7 > 6 $，比较结束，$7$ 应该放置的位置为`4`。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `3`  | `4`  | `6`  | `7`  |  2   |

5. 接下来取出下标为`5`的元素 $2$ ，将其与`[0, 4]`的元素从后向前进行比较：

   1. 首先将 $2$ 与 $7$ 进行比较，$ 7 > 2 $，$7$ 后移一位。
   2. 然后将 $2$ 与 $6$ 进行比较，$ 6 > 2 $，$6$ 后移一位。
   3. 然后将 $2$ 与 $4$ 进行比较，$4 > 2 $，$4$ 后移一位。
   4. 然后将 $2$ 与 $3$ 进行比较，$3 > 2$，$3$ 后移一位。
   5. 然后将 $2$ 与 $1$ 进行比较，$1 < 2$，比较结束，应将 $2$ 放到下标为`1`的位置上。
   6. 排序结束。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `1`  | `2`  | `3`  | `4`  | `6`  | `7`  |

## <span id="3">3. 算法实现</span>

```c++
template <typename T>
void insertionSort(T arr[], int size) { 

    T temp;
    int index;

    for (int i=0; i < size-1; i++) {
        index = i + 1;
        temp = arr[index];		// 取出下标为 i+1 的元素

        while (temp < arr[index - 1] && index > 0) {	// 查找合适的位置
            arr[index] = arr[index-1];
            index--;
        }
        arr[index] = temp;
    }
    return;
}
```

## <span id="4">4. 算法分析</span>

1. 时间复杂度为 $O(n^2) $
   1. 最好的情况是已经有序，需要比较 $ n-1 $ 次。
   2. 最坏的情况是逆序，此时需要比较$N = (n-1) + (n-2) + (n-3) + \dots + 1 = n \times (n-1) / 2$。 
2. 空间复杂度 $O(1) ​$
   * 需要一个 `temp`记录当前需要放置的元素，故而空间复杂度为 $O(1)$ 。