---
layout:     post
title:      "堆排序"
date:       2018-10-16
author:     "CongcongLi"
mathjax:    true
tags:
    - 数据结构
    - 算法
    - 堆
    - 堆排序
---

## 目录

1. [算法思想](#1)
2. [具体过程](#2)
3. [算法实现](#3)
4. [算法分析](#4)

## <span id="1">1. 算法思想</span>

1. 先将数组调整为最大堆
2. 将堆顶元素与堆尾元素交换位置，堆尺寸缩小 $1$
3. 使用shiftDown将新的堆顶元素调整到相应的位置
4. 重复步骤 2 ，直到堆的尺寸为  $1$

## <span id="2">2. 具体过程 </span>

* $ Parent(i) = (i-1) / 2 $
* $ LeftChild(i) = 2 \times i + 1 $
* $ RightChild(i) = 2 \times i + 2 $
* $ LastNonLeaf = (size - 1) / 2  , size为最后一个元素的下标 $

对以下数组进行堆排序：

| index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| data  |  5   |  4   |  9   |  8   |  6   |  7   |  2   |  9   |  9   |

1. 首先将其调整为最大堆。因为所有叶节点均满足堆的性质，所以只需要将非叶节点元素依次进行向下调整的动作即可。最后一个非叶结点的下标为 `3` 。

   1. 首先调整下标为 `3` 的元素 $ 8 $ ：

      1. 该元素小于其下标为 `7` 的左儿子节点；

      2. 该元素下标为 `7` 的左儿子节点不小于其下标为 `8` 的右儿子节点

      3. 将该元素与其左儿子节点调换位置

         | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
         | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
         | data  |  5   |  4   |  9   | `9`  |  6   |  7   |  2   | `8`  |  9   |

   2. 接下来调整下标为 `2` 的元素 $9$ ：

      * 该元素比其左右儿子节点都大，不需要调整位置。

        | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
        | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
        | data  |  5   |  4   | `9`  | `9`  |  6   |  7   |  2   | `8`  |  9   |

   3. 接下来调整下标为 `1` 的元素 $4$ ：

      1. 该元素小于其下标为 `3` 的左儿子节点；

      2. 该元素下标为 `3` 的左儿子节点大于其下标为 `4` 的右儿子节点

      3. 将该元素与其左儿子节点调换位置

         | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
         | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
         | data  |  5   | `9`  |  9   | `4`  |  6   |  7   |  2   | `8`  |  9   |

      4. 继续调整下标为 `3` 的元素 $4$：

         1. 该元素小于其下标为 `7` 的左儿子节点；

         2. 该元素下标为 `7` 的左儿子节点小于其下标为 `8` 的右儿子节点

         3. 将该元素与其右儿子节点调换位置

            | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
            | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
            | data  |  5   | `9`  |  9   | `9`  |  6   |  7   |  2   | `8`  | `4`  |

      5. 至此，对元素 $4$ 调整结束。

   4. 接下来调整下标为 `0` 的元素 $5$ ：

      1. 该元素小于其下标为 `1` 的左儿子节点；

      2. 该元素下标为 `1` 的左儿子节点不小于其下标为 `2` 的右儿子节点

      3. 将该元素与其左儿子节点调换位置

         | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
         | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
         | data  | `9`  | `5`  |  9   | `9`  |  6   |  7   |  2   | `8`  | `4`  |

      4. 继续调整下标为 `1` 的元素 $5$ ：

         1. 该元素小于其下标为 `3` 的左儿子节点；

         2. 该元素下标为 `3` 的左儿子节点大于其下标为 `4` 的右儿子节点

         3. 将该元素与其左儿子节点调换位置

            | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
            | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
            | data  | `9`  | `9`  |  9   | `5`  |  6   |  7   |  2   | `8`  | `4`  |

         4. 继续调整下标为 `3` 的元素 $5$ ：
            1. 该元素小于其下标为 `7` 的左儿子节点；

            2. 该元素下标为 `7` 的左儿子节点大于其下标为 `8` 的右儿子节点

            3. 将该元素与其左儿子节点调换位置

               | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
               | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
               | data  | `9`  | `9`  |  9   | `8`  |  6   |  7   |  2   | `5`  | `4`  |

      5. 至此，对元素 $5$ 调整完成。

   5. 至此，完成将数组构建为最大堆的过程

2. 将堆顶元素 $9$ 与堆尾元素 $4$ 交换，并将新的堆顶元素在区间 `[0, 7]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `9`  | `8`  |  9   | `5`  |  6   |  7   |  2   | `4`  | `9`  |

3. 将堆顶元素 $9$ 与堆尾元素 $4$ 交换，并将新的堆顶元素在区间 `[0, 6]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `9`  | `8`  | `7`  | `5`  |  6   | `4`  |  2   | `9`  | `9`  |

4. 将堆顶元素 $9$ 与堆尾元素 $2$ 交换，并将新的堆顶元素在区间 `[0, 5]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `8`  | `6`  | `7`  | `5`  | `2`  | `4`  | `9`  | `9`  | `9`  |

5. 将堆顶元素 $8$ 与堆尾元素 $4$ 交换，并将新的堆顶元素在区间 `[0, 4]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `7`  | `6`  | `4`  | `5`  | `2`  | `8`  | `9`  | `9`  | `9`  |

6. 将堆顶元素 $7$ 与堆尾元素 $2$ 交换，并将新的堆顶元素在区间 `[0, 3]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `6`  | `5`  | `4`  | `2`  | `7`  | `8`  | `9`  | `9`  | `9`  |

7. 将堆顶元素 $6$ 与堆尾元素 $2$ 交换，并将新的堆顶元素在区间 `[0, 2]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `5`  | `2`  | `4`  | `6`  | `7`  | `8`  | `9`  | `9`  | `9`  |

8. 将堆顶元素 $5$ 与堆尾元素 $4$ 交换，并将新的堆顶元素在区间 `[0, 1]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `4`  | `2`  | `5`  | `6`  | `7`  | `8`  | `9`  | `9`  | `9`  |

9. 将堆顶元素 $4$ 与堆尾元素 $2$ 交换，并将新的堆顶元素在区间 `[0, 0]`依次向下调整，直到调整到其合适的位置上。

   | index |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
   | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | data  | `2`  | `4`  | `5`  | `6`  | `7`  | `8`  | `9`  | `9`  | `9`  |

10. 此时区间为 `[0, 0]`， 只有一个元素，排序完成。

## <span id="3">3. 算法实现</span>

```c++
// 向下调整
template <typename T>
void shiftDown(T arr[], int index, int size) {		// [index, size] 区间内向下调整

	int leftChild, rightChild, largerChild;

	while(2 * index + 1 <= size) {
		
		leftChild = 2 * index + 1;
		rightChild = 2 * index + 2;
		largerChild = index;

		if (arr[leftChild] > arr[largerChild]) {	// 判断当前元素是否比其左儿子小
			largerChild = leftChild;
		}

		if (arr[rightChild] > arr[largerChild] && rightChild <= size) {	// 判断当前元素是否比其右儿子小
			largerChild = rightChild;
		}

		if (largerChild == index) {	// 当前元素比其儿子结点都大时，结束调整
			break;
		}
		swap(arr[largerChild], arr[index]);	// 将当前元素与其较大的儿子节点交换位置
		index = largerChild;	// 继续调整位置
	}
}

// 将数组调整为堆
template <typename T>
void heapify(T arr[], int size) {	// [0, size)区间内构建最大堆

	int lastNonLeaf = (size - 1) / 2;
	for (int i = lastNonLeaf; i >= 0; i--) {
		shiftDown(arr, i, size-1);
	}
	return;
}

template <typename T>
void heapSort(T arr[], int size) {

	heapify(arr, size);

	for (int i = 0; i < size - 1; i++) {		// 需要对 size - 1 个元素进行向下调整
		swap(arr[0], arr[size - 1 - i]);		// 将第 i 大的元素放到 size - 1 - i的位置上
		shiftDown(arr, 0, size - 2 - i);		// 对堆顶元素在区间 [0, size - 2 - i]内进行调整
	}

	return;
}
```

## <span id="4">4. 算法分析</span>

1. 时间复杂度为 $O( n \log n) $
2. 空间复杂度为 $O(1)$ 